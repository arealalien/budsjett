// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

/**
 * =========================
 * Auth & User
 * =========================
 */

enum TokenType {
  EMAIL_VERIFY
  PASSWORD_RESET
}

model User {
  id String @id @default(cuid()) @db.Char(25)

  // Auth identity
  username     String @unique @db.VarChar(50)
  email        String @unique @db.VarChar(191) // was 320 → 191 to fit utf8mb4 index limits
  passwordHash String

  // Email verification gate
  emailVerifiedAt DateTime?

  // Optional profile niceties
  displayName String? @db.VarChar(100)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ownership & membership
  budgetsOwned      Budget[]       @relation("BudgetOwner")
  budgetMemberships BudgetMember[]

  // Invites
  invitesSent     BudgetInvite[] @relation("Inviter")
  invitesReceived BudgetInvite[] @relation("Invitee")

  // Purchases
  purchasesPaid    Purchase[] @relation("PaidBy")
  purchasesCreated Purchase[] @relation("CreatedBy")

  // Shares / settlements
  shares          PurchaseShare[] @relation("ShareUser")
  settlementsMade PurchaseShare[] @relation("SettledBy")

  // Auth tokens (verification & reset)
  tokens AuthToken[]

  onboardingSkippedAt DateTime?
  Notification        Notification[]

  @@index([email])
  @@index([username])
}

/**
 * One table for both email verification and password-reset.
 */
model AuthToken {
  id         String    @id @default(cuid()) @db.Char(25)
  userId     String    @db.Char(25)
  token      String    @unique @db.VarChar(64) // was 200 → 64 (urlsafe tokens typically ~43; 64 is comfy)
  type       TokenType
  createdAt  DateTime  @default(now())
  expiresAt  DateTime
  consumedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, type])
  @@index([expiresAt])
}

/**
 * ==============
 * Notifications
 * ==============
 */

enum NotificationType {
  INVITE
}

model Notification {
  id        String           @id @default(cuid()) @db.Char(25)
  userId    String           @db.Char(25)
  type      NotificationType
  data      Json
  readAt    DateTime?
  createdAt DateTime         @default(now())

  inviteId String? @db.Char(25)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userId, readAt])
  @@index([userId, type, inviteId])
}

/**
 * =========================
 * Budgets & Membership
 * =========================
 */

enum BudgetRole {
  OWNER
  ADMIN
  MEMBER
}

enum InviteStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

model Budget {
  id   String @id @default(cuid()) @db.Char(25)
  name String @db.VarChar(191)

  owner   User   @relation("BudgetOwner", fields: [ownerId], references: [id])
  ownerId String @db.Char(25)

  slug String @unique @db.VarChar(100)

  members    BudgetMember[]
  categories Category[]
  purchases  Purchase[]
  invites    BudgetInvite[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([ownerId, name])
  @@index([ownerId])
}

model BudgetMember {
  budgetId String     @db.Char(25)
  userId   String     @db.Char(25)
  role     BudgetRole @default(MEMBER)
  joinedAt DateTime   @default(now())

  budget Budget @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([budgetId, userId])
  @@index([userId])
}

model BudgetInvite {
  id            String       @id @default(cuid()) @db.Char(25)
  budgetId      String       @db.Char(25)
  invitedUserId String?      @db.Char(25) // if inviting existing
  invitedEmail  String?      @db.VarChar(191) // was 320 → 191 to keep composite unique small
  token         String       @unique @db.VarChar(64) // was 200 → 64
  status        InviteStatus @default(PENDING)
  invitedById   String       @db.Char(25)
  createdAt     DateTime     @default(now())
  expiresAt     DateTime?

  budget      Budget @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  invitedUser User?  @relation("Invitee", fields: [invitedUserId], references: [id])
  invitedBy   User   @relation("Inviter", fields: [invitedById], references: [id])

  @@unique([budgetId, invitedEmail, status])
  @@unique([budgetId, invitedUserId, status])
  // composite unique: budgetId(25) + invitedEmail(191) + status (enum)
  @@index([budgetId])
  @@index([invitedUserId])
  @@index([invitedById])
}

/**
 * =========
 * Category
 * =========
 */

model Category {
  id       String @id @default(cuid()) @db.Char(25)
  budgetId String @db.Char(25)

  name        String  @db.VarChar(80)
  slug        String  @db.VarChar(100) // unique per budget (100 is fine)
  color       String  @db.VarChar(20)
  planMonthly Decimal @default(0.00) @db.Decimal(12, 2)
  sortOrder   Int     @default(0)
  isSystem    Boolean @default(false)

  budget    Budget     @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  purchases Purchase[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([budgetId, slug])
  @@index([budgetId, name])
}

/**
 * =========================
 * Purchases & Shares
 * =========================
 */

model Purchase {
  id       String   @id @default(cuid()) @db.Char(25)
  itemName String   @db.VarChar(191)
  amount   Decimal  @db.Decimal(12, 2)
  paidAt   DateTime @default(now())
  shared   Boolean  @default(true)
  notes    String?  @db.Text

  // Budget scoping
  budget   Budget @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  budgetId String @db.Char(25)

  // Category (per-budget)
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String   @db.Char(25)

  // Users
  paidBy   User   @relation("PaidBy", fields: [paidById], references: [id])
  paidById String @db.Char(25)

  createdBy   User   @relation("CreatedBy", fields: [createdById], references: [id])
  createdById String @db.Char(25)

  shares PurchaseShare[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@index([budgetId, paidAt])
  @@index([budgetId, categoryId, paidAt])
  @@index([budgetId, paidById, paidAt])
  @@index([budgetId, createdById, paidAt])
  @@index([paidAt])
}

model PurchaseShare {
  purchaseId  String   @db.Char(25)
  userId      String   @db.Char(25)
  percent     Int
  fixedAmount Decimal? @db.Decimal(12, 2)

  isSettled   Boolean   @default(false)
  settledAt   DateTime?
  settledById String?   @db.Char(25)

  user      User     @relation("ShareUser", fields: [userId], references: [id], onDelete: Cascade)
  settledBy User?    @relation("SettledBy", fields: [settledById], references: [id])
  purchase  Purchase @relation(fields: [purchaseId], references: [id], onDelete: Cascade)

  @@id([purchaseId, userId])
  @@index([userId])
  @@index([isSettled, settledAt])
}
