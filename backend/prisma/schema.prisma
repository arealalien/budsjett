generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ===== Enums =====
 */

enum TokenType {
  EMAIL_VERIFY
  PASSWORD_RESET
}

enum BudgetRole {
  OWNER
  ADMIN
  MEMBER
}

enum InviteStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

enum NotificationType {
  INVITE
}

enum EntryKind {
  EXPENSE
  INCOME
}

enum Recurrence {
  DAILY
  WEEKLY
  MONTHLY
  YEARLY
}

/**
 * ===== User / Auth =====
 */

model User {
  id              String    @id @default(cuid()) @db.VarChar(25)
  username        String    @unique @db.VarChar(50)
  email           String    @unique @db.VarChar(191)
  passwordHash    String
  emailVerifiedAt DateTime?
  displayName     String?   @db.VarChar(100)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Ownership & membership
  budgetsOwned      Budget[]       @relation("BudgetOwner")
  budgetMemberships BudgetMember[]

  // Invites
  invitesSent     BudgetInvite[] @relation("Inviter")
  invitesReceived BudgetInvite[] @relation("Invitee")

  // Purchases
  purchasesPaid    Purchase[] @relation("PaidBy")
  purchasesCreated Purchase[] @relation("CreatedBy")

  // Shares / settlements
  shares          PurchaseShare[] @relation("ShareUser")
  settlementsMade PurchaseShare[] @relation("SettledBy")

  // Incomes (two distinct relations to Income)
  incomesReceived Income[] @relation("IncomeReceivedBy")
  incomesCreated  Income[] @relation("IncomeCreatedBy")

  // RecurringRule relations (three distinct relations)
  recurringRulesPaidBy     RecurringRule[] @relation("RecurringPaidBy")
  recurringRulesReceivedBy RecurringRule[] @relation("RecurringReceivedBy")
  recurringRulesCreated    RecurringRule[] @relation("RecurringCreatedBy")

  // Auth tokens + notifications
  tokens       AuthToken[]
  Notification Notification[]

  onboardingSkippedAt DateTime?

  @@index([email])
  @@index([username])
}

model AuthToken {
  id         String    @id @default(cuid()) @db.VarChar(25)
  userId     String    @db.VarChar(25)
  token      String    @unique @db.VarChar(64)
  type       TokenType
  createdAt  DateTime  @default(now())
  expiresAt  DateTime
  consumedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, type])
  @@index([expiresAt])
}

model Notification {
  id        String           @id @default(cuid()) @db.VarChar(25)
  userId    String           @db.VarChar(25)
  type      NotificationType
  data      Json
  readAt    DateTime?
  createdAt DateTime         @default(now())

  inviteId String? @db.VarChar(25)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userId, readAt])
  @@index([userId, type, inviteId])
}

/**
 * ===== Budgets & Membership =====
 */

model Budget {
  id   String @id @default(cuid()) @db.VarChar(25)
  name String @db.VarChar(191)

  owner   User   @relation("BudgetOwner", fields: [ownerId], references: [id])
  ownerId String @db.VarChar(25)

  slug String @unique @db.VarChar(100)

  members    BudgetMember[]
  categories Category[]
  purchases  Purchase[]
  invites    BudgetInvite[]

  // new
  RecurringRule RecurringRule[]
  Income        Income[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([ownerId, name])
  @@index([ownerId])
}

model BudgetMember {
  budgetId String     @db.VarChar(25)
  userId   String     @db.VarChar(25)
  role     BudgetRole @default(MEMBER)
  joinedAt DateTime   @default(now())

  budget Budget @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([budgetId, userId])
  @@index([userId])
}

model BudgetInvite {
  id            String       @id @default(cuid()) @db.VarChar(25)
  budgetId      String       @db.VarChar(25)
  invitedUserId String?      @db.VarChar(25)
  invitedEmail  String?      @db.VarChar(191)
  token         String       @unique @db.VarChar(64)
  status        InviteStatus @default(PENDING)
  invitedById   String       @db.VarChar(25)
  createdAt     DateTime     @default(now())
  expiresAt     DateTime?

  budget      Budget @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  invitedUser User?  @relation("Invitee", fields: [invitedUserId], references: [id])
  invitedBy   User   @relation("Inviter", fields: [invitedById], references: [id])

  @@unique([budgetId, invitedEmail, status])
  @@unique([budgetId, invitedUserId, status])
  @@index([budgetId])
  @@index([invitedUserId])
  @@index([invitedById])
}

/**
 * ===== Category =====
 */

model Category {
  id       String @id @default(cuid()) @db.VarChar(25)
  budgetId String @db.VarChar(25)

  name        String  @db.VarChar(80)
  slug        String  @db.VarChar(100)
  color       String  @db.VarChar(20)
  planMonthly Decimal @default(0.00) @db.Decimal(12, 2)
  sortOrder   Int     @default(0)
  isSystem    Boolean @default(false)

  budget    Budget     @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  purchases Purchase[]

  // back relation from RecurringRule.category
  RecurringRule RecurringRule[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([budgetId, slug])
  @@index([budgetId, name])
}

/**
 * ===== Purchases & Shares =====
 */

model Purchase {
  id       String   @id @default(cuid()) @db.VarChar(25)
  itemName String   @db.VarChar(191)
  amount   Decimal  @db.Decimal(12, 2)
  paidAt   DateTime @default(now())
  shared   Boolean  @default(true)
  notes    String?  @db.Text

  budget   Budget @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  budgetId String @db.VarChar(25)

  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String   @db.VarChar(25)

  paidBy   User   @relation("PaidBy", fields: [paidById], references: [id])
  paidById String @db.VarChar(25)

  createdBy   User   @relation("CreatedBy", fields: [createdById], references: [id])
  createdById String @db.VarChar(25)

  shares PurchaseShare[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@index([budgetId, paidAt])
  @@index([budgetId, categoryId, paidAt])
  @@index([budgetId, paidById, paidAt])
  @@index([budgetId, createdById, paidAt])
  @@index([paidAt])
}

model PurchaseShare {
  purchaseId  String   @db.VarChar(25)
  userId      String   @db.VarChar(25)
  percent     Int
  fixedAmount Decimal? @db.Decimal(12, 2)

  isSettled   Boolean   @default(false)
  settledAt   DateTime?
  settledById String?   @db.VarChar(25)

  user      User     @relation("ShareUser", fields: [userId], references: [id], onDelete: Cascade)
  settledBy User?    @relation("SettledBy", fields: [settledById], references: [id])
  purchase  Purchase @relation(fields: [purchaseId], references: [id], onDelete: Cascade)

  @@id([purchaseId, userId])
  @@index([userId])
  @@index([isSettled, settledAt])
}

/**
 * ===== Incomes =====
 */

model Income {
  id           String   @id @default(cuid()) @db.VarChar(25)
  budgetId     String   @db.VarChar(25)
  itemName     String   @db.VarChar(191)
  amount       Decimal  @db.Decimal(12, 2)
  receivedAt   DateTime @default(now())
  receivedById String   @db.VarChar(25)
  notes        String?  @db.Text

  budget Budget @relation(fields: [budgetId], references: [id], onDelete: Cascade)

  // two relations to User need names
  receivedBy  User   @relation("IncomeReceivedBy", fields: [receivedById], references: [id])
  createdBy   User   @relation("IncomeCreatedBy", fields: [createdById], references: [id])
  createdById String @db.VarChar(25)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([budgetId, receivedAt])
}

/**
 * ===== Recurring Rules (expense + income) =====
 */

model RecurringRule {
  id       String    @id @default(cuid()) @db.VarChar(25)
  budgetId String    @db.VarChar(25)
  kind     EntryKind @default(EXPENSE)

  // EXPENSE
  categoryId String? @db.VarChar(25)
  paidById   String? @db.VarChar(25)

  // INCOME
  receivedById String? @db.VarChar(25)

  itemName String  @db.VarChar(191)
  amount   Decimal @db.Decimal(12, 2)
  notes    String? @db.VarChar(191)

  recurrence Recurrence
  interval   Int        @default(1)
  timeZone   String     @default("UTC") @db.VarChar(50)
  startAt    DateTime?
  endAt      DateTime?
  nextRunAt  DateTime
  lastRunAt  DateTime?
  active     Boolean    @default(true)

  budget   Budget    @relation(fields: [budgetId], references: [id], onDelete: Cascade)
  category Category? @relation(fields: [categoryId], references: [id])

  // three relations to User need names
  paidBy      User?  @relation("RecurringPaidBy", fields: [paidById], references: [id])
  receivedBy  User?  @relation("RecurringReceivedBy", fields: [receivedById], references: [id])
  createdBy   User   @relation("RecurringCreatedBy", fields: [createdById], references: [id])
  createdById String @db.VarChar(25)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([budgetId, active, nextRunAt])
  @@index([nextRunAt, active])
}
